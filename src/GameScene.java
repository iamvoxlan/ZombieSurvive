
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Collections;
import java.awt.Rectangle;


/**
 *
 * @author voxlan
 */
public class GameScene extends javax.swing.JPanel implements ActionListener, Runnable, KeyListener{
    
    public ArrayList<Zombie> zombies = new ArrayList<Zombie>();
    private Player player;
    private ArrayList<Obstacle> obstacles = new ArrayList<Obstacle>();
    private int skor = 0;
    private boolean gameRunning = true;
    private int x1=0;
    private int y1=0;
    private int x2=2000;
    private int dx=4;
    private int xj=0;
    private int xj2=1000;
    private int yj=300;
    private int xg=200, yg=100;
    private int count=0;
    private ArrayList<String> bangunan;
    private Image bgjalan, jalanan, gedung;
    private ArrayList<String> scene;
    private float enmin=0;
    private Obstacle testing;
    private EnergyItem energytest;
    private OffensiveItem offensetest;
    
    public GameScene(String n) 
    {
        addKeyListener(this);
        setFocusable(true);
        requestFocus(true);
        player = new Player(n);
        initComponents();
        repaint();
        Thread thread = new Thread(this);
        thread.start();
        bangunan = new ArrayList<>();
        bangunan.add("lib/1.png");
        bangunan.add("lib/2.png");
        bangunan.add("lib/3.png");
        Collections.shuffle(bangunan);
        namaGan.setText("Nama: "+player.name);
        energiGan.setText("Energi: "+player.energy);
        scene = new  ArrayList<>();
        scene.add("lib/malam.jpg");
        scene.add("lib/pagi.jpg");
        scene.add("lib/sore.jpg");
        Collections.shuffle(scene);
        testing = new Obstacle();
        energytest = new EnergyItem();
        populateZombie();
        offensetest = new OffensiveItem();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        namaGan = new javax.swing.JLabel();
        skorGan = new javax.swing.JLabel();
        energiGan = new javax.swing.JLabel();

        namaGan.setFont(new java.awt.Font("Noto Sans", 1, 14)); // NOI18N
        namaGan.setForeground(new java.awt.Color(105, 253, 14));
        namaGan.setText("Nama:");

        skorGan.setFont(new java.awt.Font("Noto Sans", 1, 14)); // NOI18N
        skorGan.setForeground(new java.awt.Color(105, 253, 14));
        skorGan.setText("Energi: ");

        energiGan.setFont(new java.awt.Font("Noto Sans", 1, 14)); // NOI18N
        energiGan.setForeground(new java.awt.Color(105, 253, 14));
        energiGan.setText("Skor:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(namaGan, javax.swing.GroupLayout.PREFERRED_SIZE, 287, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(energiGan, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 537, Short.MAX_VALUE)
                .addComponent(skorGan, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(60, 60, 60))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(namaGan)
                .addGap(2, 2, 2)
                .addComponent(energiGan, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(skorGan, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(459, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void paintComponent(Graphics g)
    {
        g=(Graphics2D) g;
        bgjalan = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource(scene.get(0)));
        jalanan = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("lib/jalan.png"));
        gedung= Toolkit.getDefaultToolkit().getImage(this.getClass().getResource(bangunan.get(count)));
        
        g.drawImage(bgjalan, x1, y1, this);
        g.drawImage(bgjalan, x2, y1,  this);
        g.drawImage(jalanan, xj, yj,  this);
        g.drawImage(jalanan, xj2, yj,  this);
        g.drawImage(gedung, xg, yg, this);
        g.drawImage(player.getImage(), player.x, player.y, this);
        //g.drawImage(coba.getImage(), coba.x, coba.y, this);
        g.drawImage(testing.getImage(), testing.x, testing.y, this);
        g.drawImage(energytest.getImage(), energytest.x, energytest.y, this);
        g.drawImage(offensetest.getImage(), offensetest.x, offensetest.y, this);
        for (int i = 0; i < zombies.size(); i++) {
            g.drawImage(zombies.get(i).getImage(), zombies.get(i).x, zombies.get(i).y, this);
        }
        
    }
    
    public void populateZombie()
    {
        Zombie newZombie = new Zombie();
        zombies.add(newZombie);
    }
    
    @Override
    public void actionPerformed(ActionEvent ae) {
        repaint();
    }

    @Override
    public void run() {
        while (gameRunning) {        
            try {
                
                x1-=dx;
                x2-=dx;
                xj-=dx;
                xj2-=dx;
                xg-=dx;
                testing.x-=dx;
                energytest.x -=energytest.dx;
                offensetest.x -= offensetest.dx;
                if (xg<=-1000)
                {
                    gedung= Toolkit.getDefaultToolkit().getImage(this.getClass().getResource(bangunan.get(count)));
                    count++;
                    xg=1000;
                    if (count>2)
                    {
                        count=0;
                    }
                }
                
                if (collisionDetect(player.getBounds(), testing.getBounds()))
                {
                    gameRunning=false;
                    //this.setVisible(false);
                    //GameOver mati = new GameOver();
                    //mati.setVisible(true);
                }
                
                if (collisionDetect(player.getBounds(), offensetest.getBounds()))
                {
                    
                    //zombies.get(0).spriteZombie = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("lib/explo.png")).getScaledInstance(120, 120, Image.SCALE_DEFAULT);
                    //zombies.remove(0);
                    skor+=30;
                }
                
                if (collisionDetect(player.getBounds(), energytest.getBounds()))
                {
                    energytest.getEnergy(player);
                    if (player.energy>100)
                    {
                        player.energy=100;
                    }
                }
                
                if (xj<=-1000)
                {
                    xj=1000;
                }  
                else if (xj2==-1000)
                {
                    xj2=1000;
                }
                
                if (x1<=-2000)
                {
                    x1=2000;
                }
                else if (x2<=-2000)
                {
                    x2=2000;
                }
                if (enmin>=1)
                {
                    player.energy--;
                    enmin=0;
                }
                if (player.energy<=0)
                {
                    gameRunning=false;
                }
                Thread.sleep(10);
                skor+=1;
                
                enmin+=0.01;
                skorGan.setText("Skor: "+Integer.toString(skor));
                energiGan.setText("Energi: "+Integer.toString(player.energy));
                System.out.println(enmin);
                repaint();
            } 
            catch (Exception e) {
            }
        }
    }

    @Override
    public void keyTyped(KeyEvent ke) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyPressed(KeyEvent ke) {
        if (ke.getKeyCode()==KeyEvent.VK_UP) {
            System.out.println("GameScene.keyPressed()");
            player.jump();
        }
        if (ke.getKeyCode()==KeyEvent.VK_DOWN) {
            System.out.println("GameScene.keyPressed()");
            player.slide();
        }
    }
    
    private boolean collisionDetect(Rectangle a, Rectangle b)
    {
        return a.intersects(b);
    }
    
    @Override
    public void keyReleased(KeyEvent ke) {
        if (ke.getKeyCode()==KeyEvent.VK_DOWN) {
            System.out.println("GameScene.keyPressed()");
            player.spriteChar = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("lib/mario.gif")).getScaledInstance(100, 100, Image.SCALE_DEFAULT);
            player.y=250;
        }
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel energiGan;
    private javax.swing.JLabel namaGan;
    private javax.swing.JLabel skorGan;
    // End of variables declaration//GEN-END:variables
}
